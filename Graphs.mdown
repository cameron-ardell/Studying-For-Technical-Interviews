# Graphs

![alt text](https://qph.ec.quoracdn.net/main-qimg-af801fb9de53a6a4d94faff793a853f0 "Graph Example")

A graph is a collection of nodes with wedges between (some of) them. Graphs can either be directed or undirected. If there is a path between every pair of nodes it is called a connected graph.


There are two common ways to represent a graph.

### Adjacency List

Every vertex (node) stores a list of adjacent vertices. In an undirected graph, an edge like (a,b) would be stored twice, once in a's adjacent vertices and once in b's adjacent vertices.

A simple defintion for a graph node could look like a tree node:
```java
class Graph {
	public Node[] nodes;
}
class Node {
	public String name;
	public Node[] children;
}
```

You can also use an array or hash table or lists (arrays, arraylists, linked lists, etc.) to store the adjacency list. This is more compact, but not as clean. The above graph could be written as:
``` java
a: [b]
b: [c,d,e]
c: [e]
d: [e]
e: [f]
f: []
g: [d]
```

### Adjacency Matrix

An adjacency matrix is an NxN boolean matrix, where N is the number of nodes, where a true value at matrix[i][j] indicates and edge from node i to node j. You can also use an integer matrix with 0s and 1s (or edge weights). The above graph could be written as:
```java
[[0,1,0,0,0,0,0],
[0,0,1,1,1,0,0],
[0,0,0,0,1,0,0],
[0,0,0,0,1,0,0],
[0,0,0,0,0,1,0],
[0,0,0,0,0,0,0],
[0,0,0,1,0,0,0]]
```

Note that unlike adjacency lists, you need to iterate through all the nodes to identify a node's neighbors

## Pros and Cons

__Adjacency list__

**Pros:** For an undirected graph, the adjacency list contains 2|__E__| elements. For a directed graph, the adjacency list contains |__E__| elements. Overall saves space, O(|V|+|E|), in the worst case C(V,2) edges, thus O(V^2). Also, adding a vertex is easier.

**Cons:** You can't look up whether an edge exists in constant time. Instead, it takes O(V) or theta(__d__), where __d__ is the degree of vertex __i__, since that's how long __i__'s adjacency list is.


__Adjacency matrix__

**Pros:** It has constant time look up or remove edges. Also, repersentation is easier to implement and follow. 

**Cons:** It takes theta(V^2) space regardless of the number of edges. Also, if you want to find which vertices are adjacent to vertex i, you have to look at all |V| entries in row i, and to find all neighbors, you need to look at 2|V| entries that are in row i and column i. Additionally, adding a vertex takes O(V^2).





